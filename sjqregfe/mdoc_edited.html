<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>mdoc_edited</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="mdoc_edited_files/libs/clipboard/clipboard.min.js"></script>
<script src="mdoc_edited_files/libs/quarto-html/quarto.js"></script>
<script src="mdoc_edited_files/libs/quarto-html/popper.min.js"></script>
<script src="mdoc_edited_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="mdoc_edited_files/libs/quarto-html/anchor.min.js"></script>
<link href="mdoc_edited_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="mdoc_edited_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="mdoc_edited_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="mdoc_edited_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="mdoc_edited_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<p>title: “Estimation of Quantile Regressions with Multiple Fixed Effects” shorttitle: “Short toc Here” author:</p>
<pre><code>- name: Fernando Rios-Avila
  email: friosavi@levy.org
  affiliations:
    - name: Levy Economics Institute
      city: Annandale-on-Hudson, NY 
- name: Leonardo Siles
  email: lsiles@fen.uchile.cl
  affiliations:
  - name: Universidad de Chile
    city: Santiago, Chile
- name: Gustavo Canavire-Bacarreza
  email: gcanavire@worldbank.org
  affiliations:
  - name: "The World Bank"
    city: Washington, DC</code></pre>
<p>shortauthor: “Rios-Avila, Siles, Canavire-Bacarreza”</p>
<p>aboutauthors: | Fernando Rios-Avila is a Research Scholar at the Levy Economics Institute of Bard College.</p>
<pre><code>Gustavo Canavire-Bacarreza is a Senior Economist at the World Bank.</code></pre>
<p>abstract: | This is an example of StataJ article made by me.</p>
<p>keywords: Stata, LaTeX, Quarto, StataJ format: stjquarto-pdf: default keep-tex: true<br>
stata:<br>
vv: “vv” ii: “ii” yyyy: “yyyy” mm: “mm” bibliography: “bibliography.bib” cite-method: natbib</p>
<section id="sec-intro" class="level1">
<h1>Introduction</h1>
<p>Quantile regression, introduced by <span class="citation" data-cites="koenker1978">@koenker1978</span>, has become an important tool in economic analysis, allowing researchers to examine how the relationship between the dependent and independent variables varies across different points of the conditional distribution of the outcome. While ordinary least squares focuses on analyzing the conditional mean, quantile regression provides a more comprehensive view of how covariates impact the entire conditional distribution of the dependent variable. This can reveal heterogeneous effects that may be otherwise overlooked when analyzing the conditional mean.</p>
<p>A relatively recent development in the literature has focused on extending quantile regression analysis in a panel data setting to account for unobserved, but time-fixed heterogeneity. This is particularly important in empirical research, where unobserved heterogeneity can bias estimates of the effects of interest. However, as it is common in the estimation of non-linear models with fixed effects, introducing fixed effects in quantile regression models poses several challenges. On the one hand, the simple inclusion of fixed effects can lead to an incidental parameter problem, which can bias estimates of the quantile coefficients <span class="citation" data-cites="neymanscott1948 lancaster2000">[@neymanscott1948; @lancaster2000]</span>. On the other hand, the computational complexity of estimating quantile regression models with fixed effects can be prohibitive, particularly for large datasets with multiple high-dimensional fixed effects. While many strategies have been proposed for estimating this type of model (see <span class="citation" data-cites="galvao2017quantile">@galvao2017quantile</span> for a review), none has become standard due to restrictive assumptions regarding the inclusion of fixed effects and the computational complexity.</p>
<p>In spite of the growing interest in estimating quantile regression models with fixed effects in applied research, particularly in the fields of labor economics, health economics, and public policy, among others, there are few commands that allow the estimation of such models. In Stata, there are three main built-in commands available for estimating quantile regression: <code>qreg</code>, <code>ivqregress</code>, and <code>bayes: qreg</code>, and none of them allow for the inclusion of fixed effects, other than using the dummy variable approach. From the community-contributed commands, there is <code>xtqreg</code>, which implements a quantile regression model with fixed effects based on the method of moments proposed by <span class="citation" data-cites="mss2019">@mss2019</span>, and more recently <code>xtmdqr</code> which implements a minimum distance estimation of quantile regression models with fixed effects described in <span class="citation" data-cites="melly2023">@melly2023</span>. In both cases, these commands are constrained to a single set of fixed effects.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>To address this, in this paper we introduce two Stata commands for estimating quantile regressions with multiple fixed effects: <code>mmqreg</code> and <code>qregfe</code>. The first command <code>mmqreg</code> is an extension of the method of moments quantile regression estimator proposed by <span class="citation" data-cites="mss2019">@mss2019</span>. The second <code>qregfe</code> implements three other approaches: an implementation of a correlated random effects estimator based on <span class="citation" data-cites="abrevaya2008">@abrevaya2008</span>, <span class="citation" data-cites="wooldridge2019">@wooldridge2019</span> and <span class="citation" data-cites="wooldridge2010">@wooldridge2010 [Ch12.10.3]</span>; the estimator proposed by <span class="citation" data-cites="canay2011">@canay2011</span>, and a proposed modification of this approach. In addition, we also present an auxiliary command <code>qregplot</code> for the visualization of the quantile regression models.</p>
<p>Both commands offer the advantage of allowing for the estimation of conditional quantile regressions while controlling for multiple fixed effects. First, they leverage existing Stata commands, as well as other community-contributed commands, to allow users to estimate quantile regression models and their standard errors under different assumptions. Second, they reduce the impact of the incidental parameters problem depending on the assumptions of the underlying data-generating process. In terms of standard errors, <code>mmqreg</code> allows for the estimation of analytical standard errors (see <span class="citation" data-cites="mss2019">@mss2019</span> and <span class="citation" data-cites="riosavila2024">@riosavila2024</span>), whereas <code>qregfe</code> emphasizes the use of bootstrap standard errors. Finally, both commands are designed to be user-friendly, allowing for the estimation of quantile regression models with fixed effects in a single line of code.</p>
<p>The remainder of the paper is organized as follows. Section 2 reviews the methodological framework for quantile regression. Section 3 describes the methods and formulas used by <code>mmqreg</code> and <code>qregfe</code> commands. Section 4 introduces the commands, along with a brief description of their syntax and options. Section 5 introduces an auxiliary command for the visualization of quantile regression models. Section 6 provides empirical applications demonstrating their use. Section 7 concludes.</p>
</section>
<section id="sec-basics" class="level1">
<h1>The Basics</h1>
<p>Quantile regressions allow researchers to identify the heterogeneous effect covariates could have over the entire conditional distribution of the dependent variable. Let <span class="math inline">\(y_i\)</span> be the dependent variable, <span class="math inline">\(x_i\)</span> the vector of covariates excluding a constant, and <span class="math inline">\(0&lt;\tau&lt;1\)</span> is a parameter such that <span class="math inline">\(q_\tau(y_i|X)\)</span> identifies the <span class="math inline">\(\tau\)</span>th quantile of the conditional distribution of <span class="math inline">\(y_i|X\)</span>. Under the assumption that conditional quantiles are linear functions of the parameters, the quantile regression model can be written as:</p>
<p><span id="eq-qr"><span class="math display">\[q_\tau(y_i|X)=\beta_0(\tau) + x_i'\beta(\tau)
\tag{1}\]</span></span></p>
<p>Where <span class="math inline">\(\beta(\tau)\)</span> is the vector of coefficients that may vary across <span class="math inline">\(\tau\)</span> and needs to be estimated, and <span class="math inline">\(x_i\)</span> is a vector of exogenous covariates that may include nonlinear functions of underlying variables. This expression indicates that, conditional on <span class="math inline">\(x\)</span>, the <span class="math inline">\(\tau\)</span>-th quantile of <span class="math inline">\(y\)</span> can be approximated by a linear function of <span class="math inline">\(X\)</span>.</p>
<p>Under the assumption that the conditional quantile function is linear and correctly specified, a useful way to think about the data-generating process is to consider the following model:</p>
<p><span id="eq-dgp"><span class="math display">\[y_i = \beta_0(U_i)+x_i'\beta(U_i)
\tag{2}\]</span></span></p>
<p>where <span class="math inline">\(U_i\)</span> is a random variable that follows a uniform distribution. It can be seen as the rank an individual belongs to among all individuals with the same characteristics. In addition, <span class="math inline">\(\beta_0\)</span> and <span class="math inline">\(\beta(U_i)\)</span> are smooth functions that depend on <span class="math inline">\(U_i\)</span>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>As explained in <span class="citation" data-cites="wooldridge2010">@wooldridge2010</span>, the coefficients of quantile regression models can be identified by minimizing the following loss function, with respect to <span class="math inline">\(\beta(\tau)\)</span>:</p>
<p><span id="eq-qloss"><span class="math display">\[
\hat\beta_0(\tau),\hat\beta(\tau) = \min_{\beta(\tau)} \sum_{i=1}^{n} \rho_\tau \big(y_i-\beta_0(\tau)-x_i'\beta(\tau)\big)
\tag{3}\]</span></span></p>
<p>Where <span class="math inline">\(\rho_\tau(u)=u\big(\tau-I(u&lt;0)\big)\)</span> is the check function, and <span class="math inline">\(I(\cdot)\)</span> is the indicator function. In essence, quantile regressions are estimating the parameters locally around the <span class="math inline">\(\tau\)</span>-th quantile, although other approaches are possible <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>Most commands for estimating quantile regression models focus on estimating the above loss function, using linear programming techniques, while others like <span class="citation" data-cites="kaplan2017">@kaplan2017</span> (<code>sivqr</code>) and <span class="citation" data-cites="chernozhukov2022">@chernozhukov2022</span> (<code>qrprocess</code>) use other optimization techniques.</p>
<p>When no unobserved heterogeneity is present, the quantile regression model can be easily implemented in a panel setting (see <span class="citation" data-cites="wooldridge2010">@wooldridge2010</span>), using a pooled version of the model. However, when unobserved heterogeneity is present explicitly, the estimation of quantile regressions is more challenging. Consider the case of panel data and the following data-generating process:</p>
<p><span id="eq-dgp-panel"><span class="math display">\[y_{it} = \beta_0(U_{it}) + x_{it}'\beta(U_{it}) + \alpha_i(U_{it})
\tag{4}\]</span></span></p>
<p>Where <span class="math inline">\(U_{it}\)</span> is a random variable that follows a uniform distribution, and <span class="math inline">\(\alpha_i(U_{it})\)</span> is the unobserved effect that varies across individuals. In this case, the conditional quantile regression model can be written as: <span id="eq-feqr"><span class="math display">\[q_\tau(y_{it}|x_{it},\alpha_i(\tau))=\beta_0(\tau) + x_{it}'\beta(\tau)+\alpha_i(\tau)
\tag{5}\]</span></span></p>
<p>This specification is explicitly considering that the unobserved effect is identified for each <span class="math inline">\(i\)</span>th observation, and that it varies across quantiles (<span class="math inline">\(\alpha_i(\tau)\)</span>). A common approach used, yet incorrect due to the incidental parameter problem, is to estimate this model by adding dummy variables for each individual in the quantile regression model (as in <span class="citation" data-cites="budig2001">@budig2001</span>), or by demeaning the explanatory variables (as in <span class="citation" data-cites="budig2010">@budig2010</span>). In contrast with standard linear models, there is no transformation of the data that can eliminate the individual fixed effects for non-linear models like quantile regressions.</p>
<p>In this framework, the problem of the incidental parameter problem occurs because the unobserved factors cannot be differenced out. In other words, unless specific assumptions are made, the estimation requires the explicit estimation of the unobserved fixed effect. Unfortunately, because the number of available observations per individual fixed effect is limited, they cannot be estimated with precision. In turn, the cumulative errors in the estimation of the fixed effects will also affect the conditional distribution of the outcome, which quantile regressions leverage on, leading to inconsistent estimates of all parameters. <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>In the next section, we present a few solutions and implementations for the estimation of quantile regression models with multiple fixed effects.</p>
<section id="sec-cre" class="level2">
<h2 class="anchored" data-anchor-id="sec-cre">Correlated Random Effects: CRE</h2>
<p>The first approach we discuss is the use of Correlated Random Effects (CRE) models for the estimation of quantile regression models. The CRE model is an alternative methodology for the estimation of fixed effects models that was proposed by <span class="citation" data-cites="mundlak1978">@mundlak1978</span> and later generalized by <span class="citation" data-cites="chamberlain1982">@chamberlain1982</span>. In contrast with standard fixed effects, the approach allows users to control for time-fixed covariates in addition to time-varying covariates. And, in contrast with the random effects model, it does not make the assumption that the unobserved effect is uncorrelated with the observed covariates. Interestingly, in the context of linear models, the CRE model is equivalent to the fixed effects model <span class="citation" data-cites="wooldridge2010">[@wooldridge2010]</span>. Consider the following model:</p>
<p><span id="eq-cre-1"><span class="math display">\[y_{it} = \beta_0 + x_{it}\beta + \alpha_i + u_{it}
\tag{6}\]</span></span></p>
<p>It is well known that if <span class="math inline">\(\alpha_i\)</span> is correlated with <span class="math inline">\(x_{it}\)</span>, the Random Effects (RE) estimator will be inconsistent, due to the omitted variable bias. The solution proposed by <span class="citation" data-cites="mundlak1978">@mundlak1978</span> and <span class="citation" data-cites="chamberlain1982">@chamberlain1982</span> was to explicitly account for that correlation in the model, by assuming the unobserved effect <span class="math inline">\(\alpha_i\)</span> is a linear projection of the observed time-varying variables plus an uncorrelated disturbance. Specifically:</p>
<p><span id="eq-cre-2"><span class="math display">\[\begin{aligned}
Mundlack:  &amp; &amp; \alpha_i &amp;= \gamma_0 + \bar x_{i}\gamma + v_i&amp;  \\\\
Chamberlain: &amp; &amp; \alpha_i &amp;= \gamma_0 + x_{i1}\gamma_1 + x_{i2}\gamma_2 + \dots + x_{iT}\gamma_T + v_i
\end{aligned}
\tag{7}\]</span></span></p>
<p>The main difference between both approaches was that <span class="citation" data-cites="chamberlain1982">@chamberlain1982</span> proposes a more flexible specification allowing all realizations of the time-varying variables to explain the unobserved effect. In contrast, Mundlak’s approach only considers the average of the time-varying variables, which is a more restrictive specification. Using either model specification, if we substitute <a href="#eq-cre-2" class="quarto-xref">Equation&nbsp;7</a> into <a href="#eq-cre-1" class="quarto-xref">Equation&nbsp;6</a>, the final model can be written as:</p>
<p><span id="eq-cre-final"><span class="math display">\[y_{it} = \beta_0 + x_{it}\beta + \gamma_0 + f(x_{it})\Gamma + v_i + u_{it}
\tag{8}\]</span></span></p>
<p>where <span class="math inline">\(f(x_{it})\)</span> can be the full set of time-varying variables or just the average of them. Notice that in this specification, <span class="math inline">\(\beta_0\)</span> and <span class="math inline">\(\gamma_0\)</span> cannot be independently identified, and that the new model now has a compound error <span class="math inline">\(v_i + u_{it}=\mu_it\)</span>, which is uncorrelated with <span class="math inline">\(x_{it}\)</span>. To account for the within individual correlation driven by <span class="math inline">\(v_i\)</span>, the CRE model should be estimated using either random effects, or clustering standard errors at the individual level (see <span class="citation" data-cites="wooldridge2010">@wooldridge2010</span> for a discussion). Interestingly, either method provides the same results if the panel data is balanced, and all covariates are strictly exogenous. However, this identity breaks down in other cases (see <span class="citation" data-cites="abrevaya2013">@abrevaya2013</span>).</p>
<p>The strategy proposed by <span class="citation" data-cites="abrevaya2008">@abrevaya2008</span> was to extend the CRE model (<span class="citation" data-cites="chamberlain1982">@chamberlain1982</span> style) for the estimation of quantile regression models. This, however, has some limitations. First, when the number of periods is large, the number of additional regressors grows quickly, which can lead to other problems during estimation. Second, while the application of <span class="citation" data-cites="chamberlain1982">@chamberlain1982</span> projection approach for unbalanced data is possible (see <span class="citation" data-cites="abrevaya2013">@abrevaya2013</span>), it is not straightforward to implement in practice, especially for the framework of quantile regressions. Instead, we follow <span class="citation" data-cites="wooldridge2010">@wooldridge2010</span> and <span class="citation" data-cites="wooldridge2019">@wooldridge2019</span>, and use the Mundlak representation of the CRE model for the estimation of quantile regression models. <span class="citation" data-cites="wooldridge2019">@wooldridge2019</span> has shown that this can be easily applied for cases with unbalanced panels, and the estimation of non-linear models.</p>
<p>Specifically, <span class="citation" data-cites="wooldridge2010">@wooldridge2010</span> suggests that we could use a local projection of the quantile-specific unobserved effect. If we concentrate on <span class="math inline">\(\alpha(U_{it})\)</span>, where <span class="math inline">\(U_{it}\)</span> is a random variable that follows a uniform distribution, we could write the unobserved effect as:</p>
<p><span id="eq-cre_alpha"><span class="math display">\[\alpha_i(U_{it})=\gamma_0(U_{it})+\bar x_i'\gamma(U_{it}) + v^{U_{it}}_i
\tag{9}\]</span></span></p>
<p>Then, we can use <a href="#eq-cre_alpha" class="quarto-xref">Equation&nbsp;9</a> to write the new Data Generating Process (DGP):</p>
<p><span id="eq-cre-dgp"><span class="math display">\[y_{it} = \beta_0(U_{it}) + x_{it}\beta(U_{it}) + \gamma_0(U_{it}) + \bar x_i'\gamma(U_{it}) + v^{U_{it}}_i
\tag{10}\]</span></span></p>
<p>Two important points to note here. First, as before, <span class="math inline">\(\beta_0(\cdot)\)</span> and <span class="math inline">\(\gamma_0(\cdot)\)</span> cannot be independently identified, which makes the interpretation of the constant term difficult. Second, <span class="math inline">\(v^{U_{it}}_i\)</span> is not a smooth function of <span class="math inline">\(U_{it}\)</span>, but rather an unrelated disturbance that is left after modeling the unobserved effect, and remains unobserved. If we assume that <span class="math inline">\(v^{U_{it}}_i\)</span> is small enough compared to the overall variation driven by <span class="math inline">\(U_{it}\)</span>, we could identify the quantile regression coefficients as follows:</p>
<p><span id="eq-cre-1way"><span class="math display">\[q_\tau(y_{it}|x_{it},\bar x_i)=b_0(\tau) + x_{it}\beta(\tau)+\bar x_i'\gamma(\tau)
\tag{11}\]</span></span></p>
<p>Which can be estimated using any standard quantile regression method. However, if <span class="math inline">\(v^{U_{it}}_i\)</span> is large, standard estimators will leverage the distribution of the compound error <span class="math inline">\(v^{U_{it}}_i\)</span> and <span class="math inline">\(U_{it}\)</span>, which may lead to inconsistent estimates of the quantile coefficients. <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p>Nevertheless, assuming that the residual <span class="math inline">\(v^{U_{it}}_i\)</span> is small, the CRE-quantile regression approach has few other benefits that may be of interest. First, as discussed in <span class="citation" data-cites="wooldridge2019">@wooldridge2019</span>, it can be easily used in the presence of unbalanced panels. Second, it may also provide an approach to control for multiple fixed effects. <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. For example, let us expand on <a href="#eq-dgp-panel" class="quarto-xref">Equation&nbsp;4</a>, and consider the case of a two-way fixed effects model:</p>
<p><span class="math display">\[y_{it} = \beta_0(U_{it}) + x_{it}'\beta(U_{it}) + \alpha_i(U_{it}) + \alpha_t(U_{it})
\]</span></p>
<p>To apply the two-way CRE model, we could use the following representation of the unobserved effects:</p>
<p><span id="eq-cre-unobs"><span class="math display">\[\alpha_i(U_{it}) + \alpha_t(U_{it}) = \gamma_0(U_{it}) + \lambda_i^x \gamma_i(U_{it}) + \lambda_t^x \gamma_t(U_{it}) + v^{U_{it}}_{it}
\tag{12}\]</span></span></p>
<p>where <span class="math inline">\(\lambda_i^x\)</span> and <span class="math inline">\(\lambda_t^x\)</span> are obtained by estimating the following model for each explanatory variable <span class="math inline">\(x_{it}\)</span>:</p>
<p><span id="eq-cre-2way"><span class="math display">\[x_{it} - \bar x = \lambda_i^x + \lambda_t^x + \epsilon_{it}
\tag{13}\]</span></span></p>
<p>We use the centered transformation of the explanatory variable, that is <span class="math inline">\(x_{it}-\bar x\)</span>, so that all <span class="math inline">\(\lambda\)</span>’s have an expected value of zero. In contrast with <span class="citation" data-cites="baltagi2023">@baltagi2023</span>, we suggest that rather than modeling each individual component separately, it is easier to think of the problem of modeling the combination of the two (or many) unobserved components as a function of <span class="math inline">\(\lambda_i^x\)</span> and <span class="math inline">\(\lambda_t^x\)</span>, which are the equivalent to <span class="math inline">\(\bar x_i\)</span> in the Mundlak one-way fixed effect model. Additionally, different from <span class="citation" data-cites="wooldridge2021">@wooldridge2021</span> and <span class="citation" data-cites="baltagi2023">@baltagi2023</span>, we emphasize that the estimation of <span class="math inline">\(\lambda_i^x\)</span> and <span class="math inline">\(\lambda_t^x\)</span> should be done simultaneously (<a href="#eq-cre-2way" class="quarto-xref">Equation&nbsp;13</a>), rather than estimating the conditional means separately. This is more general and applicable to any number of fixed effects. This can be done using an iterative process similar to <span class="citation" data-cites="rios2015">@rios2015</span> or <span class="citation" data-cites="correia_feasible_nodate">@correia_feasible_nodate</span>.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p>With these considerations, the conditional quantile regression can be written as:</p>
<p><span class="math display">\[q_\tau(y_{it}|x_{it},\lambda_i^x,\lambda_t^x)=x'_{it}\beta(\tau)+{\lambda^x_i}'\gamma_i(\tau)
+{\lambda^x_t}'\gamma_t(\tau)  
\]</span></p>
<p>Which could be extended to any number of fixed effects. As before, this approach is valid if the residual <span class="math inline">\(v^{U_{it}}_{it}\)</span> from the time and individual fixed effects (or all fixed effects considered) are small enough compared to the variation driven by the latent rank variable <span class="math inline">\(U_{it}\)</span>.</p>
<p>In terms of the standard errors, for the linear CRE model, it is suggested to use the random effects estimator, or clustering standard errors at the individual level. For the quantile regression model, clustering standard errors at the individual level is also suggested by <span class="citation" data-cites="wooldridge2010">@wooldridge2010</span>, and some routines already implement this feature. When multiple fixed effects are considered, it is suggested to use the bootstrap methods for the estimation of the standard errors.</p>
</section>
<section id="sec-canay" class="level2">
<h2 class="anchored" data-anchor-id="sec-canay">Canay (2011) Estimator</h2>
<p>The second approach under consideration is the estimator proposed by <span class="citation" data-cites="canay2011">@canay2011</span>. As mentioned before, this paper argues that the estimator proposed by <span class="citation" data-cites="abrevaya2008">@abrevaya2008</span>, and thus the implementation described above, may not provide consistent estimates of the quantile regression coefficients, as long as there is a disturbance <span class="math inline">\(v^{U_{it}}_i\)</span> left after modeling <a href="#eq-cre_alpha" class="quarto-xref">Equation&nbsp;9</a>. Instead, under the assumption that the unobserved effect is a pure location shift, they propose an alternative estimator that can be used to consistently estimate the quantile regression coefficients.</p>
<p>Before presenting the estimator, it is convenient to review a second approach that has been used to understand quantile regression models: The location-scale model. Under this specification, consider the following data generating process:</p>
<p><span id="eq-loc-scale"><span class="math display">\[\begin{aligned}
y_i &amp;= \beta_0+\beta_1 x_i + \gamma_0(U_i) + \gamma_1(U_i) x_{i} \\ \text{or}\\\\
y_i &amp;= \beta_0+\beta_1 x_i + \mu_i
\end{aligned}
\tag{14}\]</span></span></p>
<p>In this specification, we assume that <span class="math inline">\(\beta_0\)</span> and <span class="math inline">\(\beta_1\)</span> are the location parameters that capture how the whole distribution of <span class="math inline">\(y_i\)</span> is affected by <span class="math inline">\(x_i\)</span>. In contrast, <span class="math inline">\(\gamma_0(U_i)\)</span> and <span class="math inline">\(\gamma_1(U_i)\)</span> are the scale parameters that capture the heterogeneous effect of <span class="math inline">\(x_i\)</span> on <span class="math inline">\(y_i\)</span> that deviates from the location effect. When using a simple linear regression model, say via OLS, we could assume that the compound component <span class="math inline">\(\gamma_0(U_i) + \gamma_1(U_i) x_{i}\)</span> is fully captured by the error term <span class="math inline">\(\mu_i\)</span>.</p>
<p>This provides three insights. First, that OLS could be used to identify the location effect of <span class="math inline">\(x_i\)</span> on <span class="math inline">\(y_i\)</span>, which we know as the average or conditional mean effect. Second, if <span class="math inline">\(\gamma_1(U_i)\)</span> is different from zero, the model is heteroskedastic, and the quantile regression could be used to identify this type of unobserved heterogeneity. Lastly, if a covariate has no scale effect, all quantile coefficients will be the same as the OLS coefficient.</p>
<p>Although of little use, this location-scale model can be easily estimated using a two-step approach. First, estimate the location effect of <span class="math inline">\(x_i\)</span> on <span class="math inline">\(y_i\)</span> using OLS:</p>
<p><span id="eq-ls-1"><span class="math display">\[y_i = \beta_0+x_i'\beta + \mu_i
\tag{15}\]</span></span></p>
<p>Then, using the predicted residuals <span class="math inline">\(\hat \mu_i\)</span>, estimate the quantile regression model:</p>
<p><span id="eq-ls-2"><span class="math display">\[q_\tau(\hat \mu_i|x_i)=\gamma_0(\tau)+ x_i'\gamma(\tau)
\tag{16}\]</span></span></p>
<p>It is a simple exercise to show that adding <span class="math inline">\(\beta+\gamma(\tau)\)</span> provides the same point estimates as estimating the full quantile regression model. However, it does provide a simple connection between OLS and quantile regression models.</p>
<p>Now, let’s reconsider the data generating process in <a href="#eq-dgp-panel" class="quarto-xref">Equation&nbsp;4</a>. <span class="citation" data-cites="canay2011">@canay2011</span> imposes the assumption that <span class="math inline">\(\alpha_i\)</span> is a pure location shift that should be constant across quantiles. More explicitly, the data generating process in a panel data setting can be written as follows:</p>
<p><span id="eq-canay-dgp"><span class="math display">\[y_{it} = \beta_0(U_{it}) + x_{it}\beta(U_{it}) + \alpha_i
\tag{17}\]</span></span> which imply that the conditional quantile regression model can be written as:</p>
<p><span id="eq-canay-qreg"><span class="math display">\[q_\tau(y_{it}|x_it,\alpha_i) = \beta_0(\tau) + x_{it}\beta(\tau) + \alpha_i \tag{18}\]</span></span></p>
<p>This assumption has important implications for the identification of the quantile regression coefficients. First, by assuming that <span class="math inline">\(\alpha_i\)</span> is a pure location shift, it reduces the number of parameters that need to be estimated in the model, because <span class="math inline">\(\alpha_i\)</span> can now be estimated globally, while the quantile regression coefficients can be estimated locally. Second, based on the previous insights of the location-scale model, it suggests that we can estimate the quantile regression model using a two-step approach. First, estimate all location effects using OLS, and then estimate the scale effects using the predicted residuals, but excluding variables we assume have a pure location shift effect. More formally, the estimator proposed by <span class="citation" data-cites="canay2011">@canay2011</span> can be described as follows:</p>
<ol type="1">
<li>Estimate the location effect of <span class="math inline">\(x_{it}\)</span> and the unobserved heterogeneity <span class="math inline">\(\alpha_i\)</span> on <span class="math inline">\(y_{it}\)</span> using OLS:</li>
</ol>
<p><span class="math display">\[y_{it}=\beta_0 + x_{it}' \beta_1 +\alpha_i + \varepsilon_{it}\]</span></p>
<ol start="2" type="1">
<li>Use the predicted fixed effects <span class="math inline">\(\hat\alpha_i\)</span><a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> to transform the dependent variable as <span class="math inline">\(\tilde y_{it}=y_{it}-\hat\alpha_i\)</span>, and estimate the quantile regression model:</li>
</ol>
<p><span class="math display">\[q_{\tau}(\tilde y_{it}|x_{it}) = \beta_0(\tau)+x_{it}'\beta_1(\tau)\]</span></p>
<p>This simple approach allows for the identification of the quantile coefficients, by imposing the assumption that the unobserved characteristics only have a location shift effect on the outcome. In addition, like the CRE model, it can be extended to multiple fixed effects, as long as one is willing to assume that the unobserved effects are pure location shifts. For example, consider a case with two fixed effects dimensions (individual and time), under the assumption that the unobserved effects are pure location shifts, the data generating process can be written as:</p>
<p><span id="eq-canay-dgp-2way"><span class="math display">\[y_{it} = \beta_0(U_{it}) + x_{it}'\beta(U_{it}) + \alpha_i + \alpha_t \tag{19}\]</span></span></p>
<p>As before, if we assume that <span class="math inline">\(\alpha_i\)</span> and <span class="math inline">\(\alpha_t\)</span> are constant across quantiles, we could use the same two-step approach to estimate the quantile regression coefficients. First, estimate the location effects using OLS, and then estimate the quantile regression model using the predicted fixed effects.</p>
<p><span id="eq-canay-mway"><span class="math display">\[q_{\tau}(y_{it}-\hat \alpha_i - \hat \alpha_t|x_{it})=q_{\tau}(\tilde y_{it}|x_{it}) = x_{it}\beta(\tau) \tag{20}\]</span></span></p>
<p>Which again can be easily estimated using standard quantile regression methods, and extended to any number of fixed effects.</p>
</section>
<section id="sec-mcanay" class="level2">
<h2 class="anchored" data-anchor-id="sec-mcanay">Modified Canay(2011) Estimator</h2>
<p>Perhaps one of the main limitations of <span class="citation" data-cites="canay2011">@canay2011</span> is that it assumes that the unobserved effect is a pure location shift. In fact, this is one of the criticisms raised by <span class="citation" data-cites="mss2019">@mss2019</span> to the estimator. While this makes sense intuitively, because an individual will only be assigned to a single rank at a given point in time, it is not consistent with the idea that the unobserved effect is, in fact, a proxy for an unobserved characteristic of the individual, and that characteristic could have a different impact on the dependent variable across quantiles. In this case, if this assumption is violated, it may lead to inconsistent estimates of the quantile coefficients. To address this limitation, we propose a small modification to the Canay estimator.</p>
<p>We start by assuming that the unobserved effect represents some characteristics of the individual that are constant across quantiles, and that can be compared across individuals. Under this consideration, the data generating process can be written as:</p>
<p><span id="eq-mcanay-dgp"><span class="math display">\[y_{it} =\beta_0 + x_{it}'\beta + \beta_\alpha \alpha_i+ \gamma_0(U_{it}) + x_{it}'\gamma(U_{it}) + \gamma_\alpha(U_{it}) \alpha_i \tag{21}\]</span></span></p>
<p>Where <span class="math inline">\(\alpha_i\)</span> is the unobserved effect, <span class="math inline">\(\beta_\alpha\)</span> is the location coefficient of the unobserved heterogeneity, and <span class="math inline">\(\gamma(U_{it})\)</span> is a smooth function that varies across quantiles. For the identification of <span class="math inline">\(\alpha_i\)</span>, we start with the same approach as <span class="citation" data-cites="canay2011">@canay2011</span>, imposing the assumption that <span class="math inline">\(\beta_\alpha=1\)</span>. In other words, the first step from <span class="citation" data-cites="canay2011">@canay2011</span> is the same as the first step presented before.</p>
<p>The second step, however, suggests that rather than transforming the dependent variable using the predicted fixed effects, we should estimate the quantile regression model using the predicted unobserved effects as an additional explanatory variable. This can be done by estimating the following model:</p>
<p><span class="math display">\[q_{\tau}(y_{it}|x_{it},\hat \alpha_i) = x_{it}\beta(\tau)+\beta(\tau) \hat\alpha_i\]</span></p>
<p>As before, this model can be extended to multiple fixed effects, by simply estimating the unobserved effects using OLS, and then estimating the quantile regression model using the predicted unobserved effects. The main advantage over <span class="citation" data-cites="canay2011">@canay2011</span> is that this estimator allows for the unobserved effect to have a different impact on the dependent variable across quantiles, which may be more realistic in many applications. However, it assumes the OLS estimator does allow for the consistent estimation of an unobserved effect that is comparable across individuals, which may not always be the case.</p>
<p>In terms of standard errors, <span class="citation" data-cites="canay2011">@canay2011</span> provides some guidance for the derivation of analytical standard errors for their estimator. Recently, however, <span class="citation" data-cites="besstremyannaya2019">@besstremyannaya2019</span> has shown that the standard errors derivations are incorrect. Instead, based on their recommendations, we suggest that the bootstrap method should be used for the estimation of the standard errors for both the Canay and Modified Canay estimators.</p>
</section>
<section id="sec-mmqr" class="level2">
<h2 class="anchored" data-anchor-id="sec-mmqr">Method of Moments Quantile Regression <span class="citation" data-cites="mss2019">@mss2019</span></h2>
<p>The last methodology we consider is the Method of Moments Quantile Regression (MMQREG) estimator proposed by <span class="citation" data-cites="mss2019">@mss2019</span>, and extended by <span class="citation" data-cites="riosavila2024">@riosavila2024</span>. The methodology was proposed as a feasible approach to incorporate fixed effects in a quantile regression model, allowing for unobserved effects to have a different impact on the dependent variable across quantiles. This is done by separating the identification of quantile coefficients into a location, scale, and quantile effect, using a method of moments approach.</p>
<p>To understand this approach, let’s consider the data generating process from <a href="#eq-loc-scale" class="quarto-xref">Equation&nbsp;14</a>. As mentioned earlier, this approach suggests that a quantile regression model can be identified using a location-scale model, where the location effect shows the average effect of the covariates on the dependent variable, and the scale effect shows the heterogeneous effect of the covariates, as a deviation from the location effect. <span class="citation" data-cites="mss2019">@mss2019</span> extends this idea by suggesting that the scale component can be further decomposed into a pure scale effect and a mediating factor. Specifically, the author considers the case where the data generating process can be written as:</p>
<p><span id="eq-dgp_mmqreg"><span class="math display">\[\begin{aligned}
Y_{i} &amp;= \beta_0 + x_{i}' \beta + (\delta_0 + X_{i}' \delta)*\mu_i) \text{ or} \\\\
Y_{i} &amp;= \beta_0 + x_{i}' \beta + (\delta_0 + X_{i}' \delta)*F^{-1}(U_i)) \text{ or}
\end{aligned} \tag{22}\]</span></span></p>
<p>This specification assumes that <span class="math inline">\(\mu_i\)</span> is an identically and independently distributed random variable with any arbitrary distribution. <span class="math inline">\(\delta_0 + X_{i}' \delta\)</span> denotes the multiplicative scale component (heteroskedasticity-generating component), and <span class="math inline">\(\beta_0 + x_{i}' \beta\)</span> denotes the location coefficients. The second line in <a href="#eq-dgp_mmqreg" class="quarto-xref">Equation&nbsp;22</a> represents the same model, but using the inverse of the distribution function of <span class="math inline">\(U_i\)</span> as the mediating factor. As before, <span class="math inline">\(U_i\)</span> is a random variable that follows a uniform distribution and captures the rank of the individual among all individuals with the same characteristics.</p>
<p>What is interesting about this specification is that it simplifies the identification of the quantile coefficients further, by imposing a strict parametric relationship across the scale coefficients. Specifically, that they are directly related to the values of <span class="math inline">\(\mu_i\)</span> or <span class="math inline">\(F^{-1}(U_i)\)</span>. Thus, the location and scale coefficients can be identified globally, requiring only the local identification of the distribution of <span class="math inline">\(\mu_i\)</span>.</p>
<p>For this simple case, the MMQREG estimator can be described as follows:<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<ol type="1">
<li>Estimate the location effect of <span class="math inline">\(x_{i}\)</span> on <span class="math inline">\(y_{i}\)</span> using OLS:</li>
</ol>
<p><span class="math display">\[y_{i} = \beta_0 + x_{i}' \beta + R_i\]</span></p>
<ol start="2" type="1">
<li>Use the predicted residuals <span class="math inline">\(\hat R_i\)</span> to estimate the scale effect using OLS, where the dependent variable is defined as <span class="math inline">\(|\hat R_i|\)</span>:</li>
</ol>
<p><span class="math display">\[|\hat R_i| = \delta_0 + x_{i}' \delta\]</span></p>
<ol start="3" type="1">
<li>Obtain a standardized residual by dividing the residuals of (1) by the predicted scale effect from (2), and estimate the <span class="math inline">\(\tau\)</span>th unconditional quantile of this distribution:</li>
</ol>
<p><span class="math display">\[\begin{aligned}
\hat \mu_i &amp;= \frac{\hat R_i}{\delta_0 + x_{i}' \delta} \\\\
q_{\tau}(\hat \mu_i) &amp;= q_0(\tau)
\end{aligned}\]</span></p>
<ol start="4" type="1">
<li>Finally, the quantile regression coefficients can be estimated by the following equation:</li>
</ol>
<p><span class="math display">\[\beta_{\tau} = \beta + q_0(\tau) \delta\]</span></p>
<p>It can be seen that because Steps 1 and 2 are estimated globally using OLS, they can easily be extended to multiple fixed effects, without major difficulties. One can simply assume, for example, that the fixed effects are estimated using a dummy variable approach, and all the steps described above follow.<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> The derivation of standard errors follows from the use of the method of moments approach and the identification of the empirical influence functions.</p>
<p>Despite the flexibility of this approach, it is important to note that the MMQR estimator is based on the assumption that all quantile coefficients are constructed as a simple combination of the location and scale coefficients. They only differ in the value of the mediating factor, the unconditional quantile of the standardized residual. This may be a strong assumption and may not be applicable in all cases. However, it does provide a few advantages over the other approaches. First, as suggested by <span class="citation" data-cites="mss2019">@mss2019</span>, with a sufficiently flexible specification of the scale component, the MMQR estimator can capture most of the important features related to the heterogeneous effect of the covariates on the dependent variable. Second, because of the identification assumptions, this estimator avoids the problem of quantile crossing, which is common in other quantile regression models. Nevertheless, it is important to note that the MMQR estimator may not be applicable in all cases.</p>
</section>
</section>
<section id="sec-implementation" class="level1">
<h1>Implementation: <code>qregfe</code> and <code>mmqreg</code></h1>
<p>In this section, we present the commands <code>qregfe</code> and <code>mmqreg</code> for the estimation of quantile regression models with fixed effects, which implement the methodologies described in the previous section.</p>
<p>Both commands follow a similar syntax:</p>
<pre><code>qregfe depvar indepvars, q(#) [options]</code></pre>
</section>
<section id="sec:conclusions" class="level1">
<h1>Conclusions</h1>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>There are other community-contributed commands like <code>xtrifreg</code>, <code>rifhdfe</code>, <code>qregpd</code>, <code>rqr</code> among others that allow for the estimation of quantile regression models, but do not estimate conditional quantile regressions, but instead focus on unconditional quantile regressions, or quantile treatment effects.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>This way of thinking about quantile regression coefficients is similar to the use of Smooth varying coefficient models, except that the running variable is not observed.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><span class="citation" data-cites="kaplan2017">@kaplan2017</span> for example uses a nonparametric approach that produces a smooth set of beta coefficients. And <span class="citation" data-cites="bottai2019">@bottai2019</span> proposes methods for estimating parametric quantile regression models, imposing parametric restrictions on the quantile coefficients across the distribution.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>This is similar to the measuring error problem of dependent variables in quantile regression models discussed in <span class="citation" data-cites="hausman2021">@hausman2021</span>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>This is the main critique raised by <span class="citation" data-cites="canay2011">@canay2011</span> to the estimator proposed by <span class="citation" data-cites="abrevaya2008">@abrevaya2008</span>. In fact, the more dominant becomes <span class="math inline">\(v^{U_{it}}_i\)</span>, the more the estimates will resemble the OLS estimates.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><span class="citation" data-cites="baltagi2023">@baltagi2023</span> and <span class="citation" data-cites="wooldridge2021">@wooldridge2021</span> discuss this for the two-way Mundlak estimator.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>If the panel is perfectly balanced, estimating <span class="math inline">\(\lambda_i^x\)</span> and <span class="math inline">\(\lambda_t^x\)</span> separately will provide the same results as estimating them simultaneously. Internally, we use <span class="citation" data-cites="correia_feasible_nodate">@correia_feasible_nodate</span> <code>reghdfe</code> to obtain the predicted fixed effects.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Empirically, this can be done using the <code>reghdfe</code> command, as part of the <code>abs()</code> suboptions.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Further details on the implementation of the methodology can be found in <span class="citation" data-cites="mss2019">@mss2019</span>, with additional extensions in <span class="citation" data-cites="riosavila2024">@riosavila2024</span>.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>In <span class="citation" data-cites="riosavila2024">@riosavila2024</span>, additional steps are presented because of the use of partial-out covariates. However, the same results can be obtained using the simpler approach described here.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>